# Поиск загруженных участков сети при моделировании потоков

# Описание

Программа позволяет ускорить процесс нахождения загруженных участков, повышая точность и надёжность результатов за счёт использования оптимизированных алгоритмов. Это особенно актуально для анализа крупных сетей, где ручной подход не эффективен.

Подобные встроенные функции есть на Python, но разработка библиотеки на C# восполнит пробел, существующий для экосистемы .NET и удобство использования для задач оптимизации сетей, таких как транспортные, телекоммуникационные системы, сети трубопровода и т.д.

# Проблема и решение

Предположим, у нас есть транспортная сеть, соединяющая точку A и точку B, где каждая дорога имеет свою пропускную способность, зависящую от количества полос. Нам необходимо определить, может ли эта сеть пропустить такое количество автомобилей, которое в неё заехало (максимальный поток сети). Если это невозможно, значит существует  участок, который ограничивает поток (минимальный разрез сети). Но поиск его в ручную занимает значительное время, поэтому была создана программа по ускорению этого процесса.

![image.png](image.png)

![image.png](image%201.png)

На рисунке видно, что данная сеть не в состоянии пропустить такое количество автомобилей, которое в неё заходит. Следовательно, существует участок, который необходимо расширить, чтобы количество выезжающих автомобилей стало равным количеству заезжающих.

С помощью алгоритмов поиска в глубину (DFS) и Форда-Фалкерсона мы можем определить этот ограничивающий участок называемый “Минимальный разрез сети”.

![image.png](image%202.png)

# Тестирование

Для тестирования возьмем участок центра города куда утром съезжаются большинство потоков. Необходимо учесть что бы все дороги по которым можно заехать внутрь транспортной сети связывались дугами с одной вершиной под названием исток. А дороги, которые веду на выезд из транспортной сети, дугами к другой вершине – сток.

![image.png](5ba214db-db33-4e9d-afdb-8b7af0b26a9c.png)

В программе расставляем вершины и связываем их ребрами с необходимым значением. И нажимаем кнопку «Найти минимальный разрез». 

![граф без мин раз.png](788b81f7-2d01-4035-80c0-5c8f3d17b641.png)

Программа автоматически определяет ребра, относящиеся к минимальному разрезу, и выделяет их красным цветом 

![граф с опред мин раз.png](1e843f91-3868-49d3-95f7-b16c37ffed89.png)

Кроме того, появляется длинное окно со списком выполненных операций, что является одной из функций библиотеки GraphMinCutLibrary. В этом окне отображается весь процесс расчетов соответствующий выполненным алгоритмам.

![разультат №3 edited.png](%25D1%2580%25D0%25B0%25D0%25B7%25D1%2583%25D0%25BB%25D1%258C%25D1%2582%25D0%25B0%25D1%2582_3_edited.png)

# Итнерфейс

Создание вершин ЛКМ

![Создание-сети.gif](image12.gif.gif)

Создание ребер

![Создание-ребер.gif](%25D0%25A1%25D0%25BE%25D0%25B7%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5-%25D1%2580%25D0%25B5%25D0%25B1%25D0%25B5%25D1%2580.gif)

Редактирование сети - удерживание ПКМ

![Редактирование.gif](%25D0%25A0%25D0%25B5%25D0%25B4%25D0%25B0%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5.gif)

# **Алгоритм Форда-Фалкерсона по поиску максимального потока**

Задан некоторый граф *G=(V,E)*. Разобьем множество *V* на два подмножества *A* и *B*:  , причем *A* и *B* должны удовлетворять условиям:

1. Равенства входного и выходного потока. Где *j* – конечные вершины ребер, исходящих из *I*, *i* – начальные вершины ребер, входящих в *S*.
    
    $$
    F = \sum_{j}{X_{Ij}} = \sum_{i}{X_{iS}} = max
    $$
    
2. Величина потока не должна превышать пропускную способность дуги.
    
    $$
    X_{ij}\le\ r_{ij}
    $$
    
3. Количество вещества, поступающего в вершину *j*, равно количеству вещества, из нее вытекающего.
    
    $$
    \sum_{j} ^{n} {X_{ij}} = 0 (i \neq I,S)
    $$
    
4. Если объем ресурсов передается от вершины *i* к вершине *j*, то равный по величине, но противоположный по направлению поток должен быть перенесен от вершины *j* к вершине *i*.   
    
    $$
    X_{ij}=-X_{ji}
    $$
    

   

Рассматриваемые случаи позволяют построить следующий алгоритм определения максимального потока.

1. Построить матрицу пропускных способностей *R* и начальный поток *X*
    
    $$
    X=\left\{X^0_{ij}\right\}
    
    $$